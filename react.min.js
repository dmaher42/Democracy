// Minimal React shim for Democracy app
(function() {
  'use strict';
  
  let renderCallbacks = [];
  let hooks = [];
  let hookIndex = 0;
  let isRendering = false;
  let componentInstance = null;
  
  function scheduleRender() {
    if (isRendering) return;
    isRendering = true;
    setTimeout(() => {
      renderCallbacks.forEach(callback => callback());
      isRendering = false;
    }, 0);
  }
  
  window.React = {
    useState: function(initialState) {
      const currentIndex = hookIndex++;
      
      if (hooks[currentIndex] === undefined) {
        hooks[currentIndex] = typeof initialState === 'function' ? initialState() : initialState;
      }
      
      const setState = function(newState) {
        if (typeof newState === 'function') {
          hooks[currentIndex] = newState(hooks[currentIndex]);
        } else {
          hooks[currentIndex] = newState;
        }
        scheduleRender();
      };
      
      return [hooks[currentIndex], setState];
    },
    
    useEffect: function(callback, deps) {
      // Simple implementation - always run callback
      try {
        const cleanup = callback();
        if (typeof cleanup === 'function') {
          // Store cleanup function if needed
        }
      } catch (e) {
        console.warn('useEffect callback error:', e);
      }
    },
    
    useMemo: function(callback, deps) {
      try {
        return callback();
      } catch (e) {
        console.warn('useMemo callback error:', e);
        return undefined;
      }
    },
    
    useRef: function(initialValue) {
      return { current: initialValue };
    },
    
    createElement: function(type, props, ...children) {
      return { type, props: props || {}, children: children.flat() };
    }
  };
  
  function renderElement(element) {
    if (!element) return null;
    if (typeof element === 'string' || typeof element === 'number') {
      return document.createTextNode(String(element));
    }
    
    if (typeof element.type === 'function') {
      hookIndex = 0;
      try {
        const result = element.type({ ...element.props, children: element.children });
        return renderElement(result);
      } catch (error) {
        console.error('Error rendering component:', error);
        const errorDiv = document.createElement('div');
        errorDiv.style.color = 'red';
        errorDiv.style.padding = '20px';
        errorDiv.style.border = '1px solid red';
        errorDiv.textContent = 'Error: ' + error.message;
        return errorDiv;
      }
    }
    
    if (!element.type) {
      console.warn('Element has no type:', element);
      return null;
    }
    
    const domElement = document.createElement(element.type);
    
    if (element.props) {
      Object.keys(element.props).forEach(key => {
        if (key === 'children') return; // Skip children prop
        
        try {
          if (key === 'className') {
            domElement.className = element.props[key];
          } else if (key === 'onClick') {
            domElement.addEventListener('click', element.props[key]);
          } else if (key === 'onChange') {
            domElement.addEventListener('change', element.props[key]);
          } else if (key === 'onInput') {
            domElement.addEventListener('input', element.props[key]);
          } else if (key === 'value') {
            domElement.value = element.props[key];
          } else if (key === 'placeholder') {
            domElement.placeholder = element.props[key];
          } else if (key === 'type') {
            domElement.type = element.props[key];
          } else if (key === 'id') {
            domElement.id = element.props[key];
          } else if (key.startsWith('data-') || key.startsWith('aria-')) {
            domElement.setAttribute(key, element.props[key]);
          }
        } catch (e) {
          console.warn('Error setting prop', key, ':', e);
        }
      });
    }
    
    if (element.children) {
      element.children.forEach(child => {
        try {
          const childNode = renderElement(child);
          if (childNode) {
            domElement.appendChild(childNode);
          }
        } catch (e) {
          console.warn('Error rendering child:', e);
        }
      });
    }
    
    return domElement;
  }
  
  window.ReactDOM = {
    createRoot: function(container) {
      return {
        render: function(element) {
          const renderFunction = () => {
            hookIndex = 0;
            try {
              const rendered = renderElement(element);
              container.innerHTML = '';
              if (rendered) {
                container.appendChild(rendered);
              }
            } catch (error) {
              console.error('Render error:', error);
              container.innerHTML = '<div style="color: red; padding: 20px;">Error rendering app: ' + error.message + '</div>';
            }
          };
          
          renderCallbacks = [renderFunction];
          renderFunction();
        }
      };
    }
  };
})();